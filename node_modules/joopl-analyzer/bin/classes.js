/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Dependency Analyzer
 https://github.com/mfidemraizer/joopl

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

var fs = require("fs");
var q = require("q");
var walk = require("walk");
var underscore = require("underscore");
var esprima = require("esprima");
var colors = require("colors");
var path = require("path");
var jsBeautify = require("js-beautify").js_beautify;

var Logger = function () { };

Logger.prototype = {
    logAlways: function (text, formatArgs) {
        if (typeof formatArgs == "undefined") {
            console.log(text);
        } else {
            console.log(text, formatArgs);
        }
    },

    logInfo: function (text, formatArgs) {
        if (Logger.enabled) {
            if (typeof formatArgs == "undefined") {
                console.log(text);
            } else {
                console.log(text, formatArgs);
            }
        }
    },

    logWarning: function (text, formatArgs) {
        if (Logger.enabled) {
            if (typeof formatArgs == "undefined") {
                console.log(text.yellow);
            } else {
                console.log(text.yellow, formatArgs);
            }
        }
    },

    logError: function (text, formatArgs) {
        if (typeof formatArgs == "undefined") {
            console.log(text.red);
        } else {
            console.log(text.red, formatArgs);
        }
    },

    logSuccess: function (text, formatArgs) {
        if (Logger.enabled) {
            if (typeof formatArgs == "undefined") {
                console.log(text.green);
            } else {
                console.log(text.green, formatArgs);
            }
        }
    }
};

Object.defineProperty(Logger, "enabled", { value: true, writable: true, configurable: false });
Object.defineProperty(Logger, "default", { value: new Logger(), writable: false, configurable: false });

var DependencyAnalyzer = function () { };

Object.defineProperty(
    DependencyAnalyzer,
    "configuration", {
        get: function () {
            if (!this.hasOwnProperty("_configuration")) {
                var configurationUri = this.baseDirectory + "/" + "joopl-analyzer.json";
                var configuration = null;

                if (fs.existsSync(configurationUri)) {
                    configuration = JSON.parse(fs.readFileSync(configurationUri, "utf-8").trim());
                } else {
                    configuration = {
                        fileExcludes: []
                    };
                }

                this._configuration = configuration;
            }

            return this._configuration;
        },
        configurable: false
    }
);

DependencyAnalyzer.prototype = {
    start: function (args) {
        var that = this;
        var deferred = q.defer();

        DependencyAnalyzer.baseDirectory = args.baseDirectory;

        this.loadFilesAsync(args.baseDirectory).then(function (sourceFiles) {
            var mapBuilder = new DependencyMapBuilder();
            that._map = mapBuilder.buildSync(sourceFiles, args.baseDirectory);

            deferred.resolve();
        });

        return deferred.promise;
    },

    get map() {
        return this._map;
    },

    loadFilesAsync: function (baseUri) {
        var deferred = q.defer();
        var sourceFiles = [];

        var walker = walk.walk(baseUri, { followLinks: false });

        walker.on("file", function (root, stat, next) {
            var fullFileName = root + '/' + stat.name;
            var isExcluded = underscore.some(DependencyAnalyzer.configuration.fileExcludes, function (excludedFileName) {
                return fullFileName.indexOf(excludedFileName) == 0;
            });

            if (!isExcluded && stat.name.indexOf("moduleinfo.js") == -1 && path.extname(stat.name) == ".js") {
                sourceFiles.push(fullFileName);
            } else if (isExcluded) {
                Logger.default.logInfo("File '" + fullFileName + "' has been excluded.");
            }

            next();
        });

        walker.on("end", function () {
            deferred.resolve(sourceFiles);
        });

        return deferred.promise;
    }
};

var DependencyMapBuilder = function () {
    this._parsedFiles = {};
    this._parsedMembers = {};
    this._newInstanceRegex = /new [a-z0-9.]+\.[a-z0-9]+/mig;
    this._newInstanceMemberNameRegex = /new [a-z0-9]+\./mig;
    this._newGlobalInstanceRegex = /new\s+\$global\.(?:[a-z0-9]+\.)+(?:[a-z0-9]+).+;$/mig;
};

DependencyMapBuilder.prototype = {
    get parsedFiles() {
        return this._parsedFiles;
    },

    get parsedMembers() {
        return this._parsedMembers;
    },

    get newInstanceRegex() {
        // This is important since this regexp has the global modifier
        // and this means last search will leave the index where something
        // was found for the next search...
        this._newInstanceRegex.lastIndex = 0;

        return this._newInstanceRegex;
    },

    get newInstanceMemberNameRegex() {
        this._newInstanceMemberNameRegex.lastIndex = 0;
        return this._newInstanceMemberNameRegex;
    },

    get newGlobalInstanceRegex() {
        this._newGlobalInstanceRegex.lastIndex = 0;
        return this._newGlobalInstanceRegex;
    },

    buildSync: function (sourceFiles, baseDirectory) {
        var that = this;
        var namespaces = {};

        sourceFiles.forEach(function (sourceFile) {
            try {
                var parsedNamespaces = that.parseSourceFileSync(sourceFile);
                var namespaceFullNames = Object.keys(parsedNamespaces);
                var tempFullName = null;
                var tempNs = null;

                for (var nsIndex in namespaceFullNames) {
                    tempFullName = namespaceFullNames[nsIndex];
                    tempNs = parsedNamespaces[tempFullName];

                    if (!namespaces.hasOwnProperty(tempFullName)) {
                        namespaces[tempFullName] = tempNs;
                    }

                    for (var memberIndex in tempNs.members) {
                        if (namespaces[tempFullName].members.indexOf(tempNs.members[memberIndex]) == -1) {
                            namespaces[tempFullName].members.push(tempNs.members[memberIndex]);
                        }

                        that.parsedMembers[tempFullName + "." + tempNs.members[memberIndex].name] = tempNs.members[memberIndex];
                    }
                }

                Logger.default.logSuccess("Parsing file '" + sourceFile + "' succeded");
            } catch (e) {
                Logger.default.logError("Parsing file '" + sourceFile + "' failed (reason: '" + e.toString() + "')");
            }
        });

        var fileDependencyMaps = this.buildUsageMapSync(namespaces, sourceFiles);
        var finalResultJsSource = "$import.mapMany(" + JSON.stringify(fileDependencyMaps) + ");";

        finalResultJsSource = jsBeautify(finalResultJsSource, {
            "indent_size": 4,
            "indent_char": " ",
            "indent_level": 0,
            "indent_with_tabs": true,
            "preserve_newlines": true,
            "max_preserve_newlines": 10,
            "jslint_happy": true,
            "brace_style": "expand",
            "keep_array_indentation": false,
            "keep_function_indentation": false,
            "space_before_conditional": true,
            "break_chained_methods": false,
            "eval_code": false,
            "unescape_strings": false,
            "wrap_line_length": 40
        });

        // Iterates over base directory overrides and performs string replacement operations
        if (DependencyAnalyzer.configuration.hasOwnProperty("baseDirectoryOverrides")) {
            DependencyAnalyzer.configuration.baseDirectoryOverrides.forEach(function (override) {
                finalResultJsSource = finalResultJsSource.replace(
                    new RegExp("\"(" + override.startsWith + ")((?:[a-z0-9./]+).js)\"", "mig"),
                    "\"" + override.replaceWith + "\""
                );
            });
        }

        fs.writeFileSync(
            path.join(baseDirectory, "moduleinfo.js"),
            finalResultJsSource,
            { encoding: "utf8" }
        );
    },

    parseSourceFileSync: function (sourceFile) {
        var ast = esprima.parse(fs.readFileSync(sourceFile, 'utf8'), { range: true }).body;
        this.parsedFiles[sourceFile] = ast;

        return this.parseAstSync(sourceFile, ast);
    },

    parseAstSync: function (sourceFile, ast, namespaces) {
        var isFirstCall = !namespaces;
        var that = this;
        var namespaces = namespaces ? namespaces : {};
        var declarationInfo = {
            memberDeclarationCount: 0
        };

        ast.forEach(function (node) {
            switch (node.type) {
                case "FunctionExpression":
                    that.parseAstSync(sourceFile, node.body.body, namespaces);
                    break;

                case "ExpressionStatement":
                    if (node.expression.type == "CallExpression" && node.expression.callee) {
                        var callee = node.expression.callee;
                        var arguments = node.expression.arguments;

                        switch (callee.type) {
                            // When it's a self-invoked function
                            case "FunctionExpression":
                                that.parseAstSync(sourceFile, callee.body.body, namespaces);
                                break;

                                // When it's some instance method call
                            case "MemberExpression":
                                if (typeof callee.object != "undefined") {
                                    if (callee.object.name == "$import" && callee.property.name == "modules") {
                                        var callbackFunc = underscore.findWhere(arguments, { type: "FunctionExpression" });
                                        that.parseAstSync(sourceFile, [callbackFunc], namespaces);
                                    }
                                        // When registering a new namespace...
                                    else if (callee.object.name == "$namespace" && callee.property.name == "using") {
                                        var namespacePaths = underscore.where(arguments, { type: "Literal" }).map(function (arg) {
                                            return arg.value;
                                        });

                                        var namespaceCall = underscore.find(arguments, function (arg) {
                                            return arg.type == "FunctionExpression";
                                        });
                                        var namespaceScope = namespaceCall.body.body;
                                        var namespaceAliases = {};

                                        var nsIndex = 0;

                                        namespaceCall.params.forEach(function (param) {
                                            namespaceAliases[param.name] = namespacePaths[nsIndex];
                                            nsIndex++;
                                        });

                                        namespacePaths.forEach(function (namespacePath) {
                                            if (!namespaces.hasOwnProperty(namespacePath)) {
                                                namespaces[namespacePath] = {
                                                    fullName: namespacePath,
                                                    name: namespacePath.split(".").pop(),
                                                    members: []
                                                };
                                            }
                                        });

                                        that.parseNamespaceScopeAstSync(namespaceScope, sourceFile, namespaces, namespaceAliases, declarationInfo);
                                    }
                                }
                                break;
                        }
                    }

                    break;
            }
        });

        return isFirstCall ? namespaces : null;
    },

    parseNamespaceScopeAstSync: function (ast, sourceFile, namespaces, namespaceAliases, declarationInfo) {
        var that = this;

        ast.forEach(function (node) {
            switch (node.type) {
                case "ExpressionStatement":
                    switch (node.expression.type) {
                        case "CallExpression":
                            var callee = node.expression.callee;

                            if (callee.type == "MemberExpression" && typeof callee.object != "undefined" && callee.object.type == "Identifier") {
                                var namespace = namespaces[namespaceAliases[callee.object.name]];

                                if (typeof namespace != "undefined") {
                                    var arguments = node.expression.arguments;
                                    var declarationOptions = arguments[1].properties;
                                    var member;

                                    if (callee.property.name == "declareClass") {
                                        if (declarationInfo.memberDeclarationCount > 0) {
                                            Logger.default.logWarning("File '" + sourceFile + "' declares more than a namespace member. First member will be taken and others skipped.");
                                            break;
                                        }

                                        declarationInfo.memberDeclarationCount++;

                                        member = {
                                            type: "class",
                                            name: arguments[0].value,
                                            parentNamespace: namespace,
                                            sourceFile: sourceFile,
                                        };
                                        namespace.members.push(member);

                                        // Gets class declaration parameters
                                        var options = that.parseClassDeclarationOptionsSync(declarationOptions, namespaces, namespaceAliases);

                                        // Has inheritance?
                                        if (options.hasOwnProperty("inherits")) {
                                            member.inherits = options.inherits;
                                        }

                                    } else if (callee.property.name == "declareEnum") {
                                        if (declarationInfo.memberDeclarationCount > 0) {
                                            Logger.default.logWarning("File '" + sourceFile + "' declares more than a namespace member. First member will be taken and others skipped.");

                                            break;
                                        }

                                        declarationInfo.memberDeclarationCount++;

                                        member = {
                                            type: "enum",
                                            name: arguments[0].value,
                                            parentNamespace: namespace,
                                            sourceFile: sourceFile,
                                        };

                                        namespace.members.push(member);
                                    }
                                }
                            }
                            break;
                    }
                    break;
            }
        });
    },

    parseClassDeclarationOptionsSync: function (options, namespaces, namespaceAliases) {
        var result = {};
        var that = this;

        options.forEach(function (option) {
            if (option.type == "Property") {
                switch (option.key.name) {
                    case "inherits":
                        var baseClass = null;

                        if (option.value.type == "MemberExpression") {
                            switch (option.value.object.type) {
                                case "Identifier":
                                    var namespace = namespaces[namespaceAliases[option.value.object.name]];

                                    if (typeof namespace != "undefined") {
                                        baseClass = { fullNamespaceName: namespace.fullName, name: option.value.property.name };
                                    }
                                    break;

                                case "MemberExpression":
                                    baseClass = that.getFullObjectNameFromAstSync(option.value);
                                    break;

                            }
                        }

                        if (baseClass != null) {
                            result.inherits = baseClass;
                        }
                        break;
                }
            }
        });

        return result;
    },

    getFullObjectNameFromAstSync: function (memberExpressionAst) {
        var lastExpr = memberExpressionAst;
        var fullName = [];

        while (typeof lastExpr !== "undefined") {
            if (lastExpr.type != "Identifier") {
                fullName.push(lastExpr.property.name);
                lastExpr = lastExpr.object;
            } else {
                lastExpr = undefined;
            }
        }

        if (fullName.length > 0) {
            var className = fullName[0];

            fullName.splice(0, 1);
            fullName.reverse();

            return { fullNamespaceName: fullName.join("."), name: className };
        } else {
            return null;
        }
    },

    buildUsageMapSync: function (namespaces) {
        var that = this;

        var dependentFiles = {};

        Object.keys(this.parsedFiles).forEach(function (parsedFile) {
            try {
                var ast = that.parsedFiles[parsedFile];

                dependentFiles[parsedFile] = [];
                that.getDependentFilesFromAstSync(parsedFile, ast, namespaces, dependentFiles[parsedFile]);

                Logger.default.logSuccess("Detecting dependencies from file '" + parsedFile + "' succeded");
            } catch (e) {
                Logger.default.logError("Detecting dependencies from file '" + parsedFile + "' failed (reason: '" + e.toString() + "')");
            }
        });

        Object.keys(dependentFiles).forEach(function (uri) {
            try {
                var files = dependentFiles[uri].concat();

                dependentFiles[uri].forEach(function (fileName) {
                    var result = [];
                    var ast = that.parsedFiles[fileName];

                    that.getDependentFilesFromAstSync(fileName, ast, namespaces, result);

                    var injectPosition;

                    result.forEach(function (detectedFile) {
                        if (files.indexOf(detectedFile) == -1) {
                            var member = underscore.find(that.parsedMembers, function(member) {
                                return member.sourceFile == detectedFile; 
                            });

                            if(typeof member != "undefined" && member.type == "class") {
                                if(member.hasOwnProperty("inherits")) {
                                    var baseClassFullName = member.inherits.fullNamespaceName + "." + member.inherits.name;
                                    var baseClass = that.parsedMembers[baseClassFullName];
                                    injectPosition = files.indexOf(baseClass.sourceFile);

                                    if(injectPosition > -1) {
                                        injectPosition++;
                                        files.splice(injectPosition, 0, detectedFile);
                                    } else {
                                        files.push(detectedFile);
                                    }
                                } else {
                                    files.push(detectedFile);
                                }
                            } else if (files.indexOf(detectedFile) == -1) {
                                files.push(detectedFile);
                            }
                        }
                    });
                });

                dependentFiles[uri] = files;
            } catch (e) {
                Logger.default.logError("Detecting dependencies from file '" + uri + "' failed (reason: '" + e.toString() + "')");
            }
        });

        Object.keys(dependentFiles).forEach(function (uri) {
            try {
                var files = dependentFiles[uri];
                var indexOfFile = files.indexOf(uri);

                if (indexOfFile > -1) {
                    files.splice(indexOfFile, 1);
                    files.push(uri);
                }
            } catch (e) {
                Logger.default.logError("Detecting dependencies from file '" + uri + "' failed (reason: '" + e.toString() + "')");
            }
        });

        var finalResult = {};

        Object.keys(dependentFiles).forEach(function (fullFileName) {
            var members = underscore.filter(that.parsedMembers, function (some) {
                return some.sourceFile == fullFileName;
            });

            members.forEach(function (member) {
                finalResult[member.parentNamespace.fullName + "." + member.name] = dependentFiles[fullFileName];
            });
        });

        return finalResult;
    },

    getDependentFilesFromAstSync: function (parsedFile, ast, namespaces, dependentFiles, importedModules) {
        var that = this;

        ast.forEach(function (node) {
            switch (node.type) {
                case "FunctionExpression":
                    that.getDependentFilesFromAstSync(parsedFile, node.body.body, namespaces, dependentFiles, importedModules);
                    break;

                case "ExpressionStatement":
                    if (node.expression.type == "CallExpression" && node.expression.callee) {
                        var callee = node.expression.callee;
                        var arguments = node.expression.arguments;

                        switch (callee.type) {
                            // When it's a self-invoked function
                            case "FunctionExpression":
                                that.getDependentFilesFromAstSync(parsedFile, callee.body.body, namespaces, dependentFiles, importedModules);
                                break;

                                // When it's some instance method call
                            case "MemberExpression":
                                if (typeof callee.object != "undefined") {
                                    if (callee.object.name == "$import" && callee.property.name == "modules") {
                                        importedModules = underscore.where(arguments, { type: "Literal" }).map(function(literal) {
                                            return literal.value;
                                        });
                                        var callbackFunc = underscore.findWhere(arguments, { type: "FunctionExpression" });

                                        that.getDependentFilesFromAstSync(parsedFile, [callbackFunc], namespaces, dependentFiles, importedModules);
                                    }
                                        // When registering a new namespace...
                                    else if (callee.object.name == "$namespace" && callee.property.name == "using") {
                                        var namespacePaths = underscore.where(arguments, { type: "Literal" }).map(function (arg) {
                                            return arg.value;
                                        });

                                        var namespaceCall = underscore.find(arguments, function (arg) {
                                            return arg.type == "FunctionExpression";
                                        });
                                        var namespaceScopeAst = namespaceCall.body.body;
                                        var namespaceAliases = {};

                                        var nsIndex = 0;

                                        namespaceCall.params.forEach(function (param) {
                                            namespaceAliases[param.name] = namespacePaths[nsIndex];
                                            nsIndex++;
                                        });

                                        that.detectMembersFromNamespaceScopeSync(parsedFile, namespaceScopeAst, namespaceAliases, namespaces, dependentFiles, importedModules);
                                    }
                                }
                                break;
                        }
                    }

                    break;
            }
        });
    },

    detectMembersFromNamespaceScopeSync: function (parsedFile, namespaceScopeAst, namespaceAliases, namespaces, dependentFiles, importedModules) {
        var that = this;
        var parsedFileContents = fs.readFileSync(parsedFile, "utf8");

        namespaceScopeAst.forEach(function (node) {
            switch (node.type) {
                case "MemberExpression":
                case "ExpressionStatement":
                    switch (node.expression.type) {
                        case "CallExpression":
                        case "NewExpression":
                            var callee = node.expression.callee;

                            if (callee.type == "MemberExpression") {
                                if (typeof callee.object == "undefined" && callee.object.type != "Identifier") {
                                    break;
                                }

                                var nsPath = namespaceAliases[callee.object.name];
                                var ns = namespaces[nsPath];

                                if (typeof ns != "undefined") {
                                    var arguments = node.expression.arguments;
                                    var memberName = null;

                                    if (callee.property.name == "declareClass" || callee.property.name == "declareEnum") {
                                        memberName = arguments[0].value;
                                    } else {
                                        memberName = callee.property.name;
                                    }

                                    var foundMember = underscore.findWhere(ns.members, { name: memberName });

                                    if (typeof foundMember != "undefined") {
                                        if (foundMember.hasOwnProperty("inherits")) {
                                            var files = that.getHierarchyDependenciesFromAstSync(foundMember);

                                            for (var fileIndex = 0; fileIndex < files.length; fileIndex++) {
                                                if (dependentFiles.indexOf(files[fileIndex]) == -1) {
                                                    dependentFiles.push(files[fileIndex]);
                                                }
                                            }
                                        }

                                        if ( // Maybe imported module is the same file where the current declaring member lives in, so it shouldn't be included in dependencies
                                            // as it may mean that this file will be loaded using another approach...
                                            (importedModules != null && importedModules.indexOf(nsPath + "." + memberName) == -1 && dependentFiles.indexOf(foundMember.sourceFile) == -1)
                                            ||
                                            (importedModules == null && dependentFiles.indexOf(foundMember.sourceFile) == -1)
                                        ) {
                                            dependentFiles.push(foundMember.sourceFile);
                                        }
                                    }

                                    if (arguments.length == 2 && arguments[1].hasOwnProperty("properties")) {
                                        var declarationOptions = {};

                                        arguments[1].properties.forEach(function (arg) {
                                            declarationOptions[arg.key.name] = arg.value;
                                        });

                                        var hasMembers = declarationOptions.hasOwnProperty("members");

                                        // Class constructor will be treated like a regular class member
                                        if (declarationOptions.hasOwnProperty("ctor") && declarationOptions.ctor.type == "FunctionExpression") {
                                            // This simulates a Esprima syntax tree node
                                            var ctor = {
                                                key: {
                                                    type: "Identifier",
                                                    name: "ctor"
                                                },
                                                value: declarationOptions.ctor
                                            };

                                            if (!hasMembers) {
                                                declarationOptions.members = {
                                                    type: "ObjectExpression",
                                                    properties: [ctor]
                                                };

                                                hasMembers = true;
                                            } else {
                                                declarationOptions.members.properties.push(ctor);
                                            }
                                        }

                                        if (hasMembers && declarationOptions.members.type == "ObjectExpression") {
                                            var classMembers = declarationOptions.members.properties;

                                            var memberDependentFiles = [];

                                            classMembers.forEach(function (memberAst) {
                                                if (memberAst.value.type == "FunctionExpression") {
                                                    var memberContent = parsedFileContents.substring(memberAst.value.body.range[0], memberAst.value.body.range[1]);

                                                    // Enum analysis
                                                    var aliases = "(?:" + Object.keys(namespaceAliases).join("|") + ")";
                                                    var detectedEnums = memberContent.match(new RegExp(aliases + "\.([a-z0-9_]+)\.(?:[a-z0-9_]+[.]+|[a-z0-9_]+)+", "mig"));

                                                    if (detectedEnums != null) {
                                                        detectedEnums.forEach(function (enumSourceCode) {
                                                            var enumParts = enumSourceCode.replace(";", "").replace(" ", "").replace(":", "").split(".");
                                                            var enumNs = namespaces[namespaceAliases[enumParts[0]]];

                                                            if (typeof enumNs != "undefined") {
                                                                var enumName = enumNs.fullName + "." + enumParts[1];

                                                                if (that.parsedMembers.hasOwnProperty(enumName)) {
                                                                    var enumMember = that.parsedMembers[enumName];

                                                                    if (dependentFiles.indexOf(enumMember.sourceFile) == -1 && memberDependentFiles.indexOf(enumMember.sourceFile) == -1) {
                                                                        memberDependentFiles.push(enumMember.sourceFile);
                                                                    }
                                                                }
                                                            }
                                                        });
                                                    }

                                                    // Class instance analysis
                                                    var newInstances = that.newInstanceRegex.exec(memberContent);
                                                    var newGlobalInstances = that.newGlobalInstanceRegex.exec(memberContent);

                                                    var result = newInstances;

                                                    if (newGlobalInstances != null) {
                                                        if (newInstances != null) {
                                                            result = result.concat(newGlobalInstances);
                                                        } else {
                                                            result = newGlobalInstances;
                                                        }
                                                    }

                                                    if (result != null) {
                                                        var nsIndex = 0;
                                                        ns = null;
                                                        var innerFoundMember = undefined;
                                                        var tempMemberName;

                                                        result.forEach(function (newExpressionText) {
                                                            switch (newExpressionText.indexOf("$global")) {
                                                                case -1:
                                                                    tempMemberName = newExpressionText.replace("new", "").replace(" ", "").split(".");

                                                                    if (namespaceAliases.hasOwnProperty(tempMemberName[0])) {
                                                                        innerFoundMember = underscore.findWhere(namespaces[namespaceAliases[tempMemberName[0]]].members, { name: tempMemberName[1] });
                                                                    }

                                                                    break;
                                                                default:
                                                                    tempMemberName = newExpressionText.substring(
                                                                        newExpressionText.indexOf(".") + 1,
                                                                        newExpressionText.indexOf("(")
                                                                    );

                                                                    tempMemberName = tempMemberName.replace(" ", "");
                                                                    tempMemberName = tempMemberName.replace("$global.", "");

                                                                    if (that.parsedMembers.hasOwnProperty(tempMemberName)) {
                                                                        innerFoundMember = that.parsedMembers[tempMemberName];
                                                                    }

                                                                    break;
                                                            }

                                                            if (typeof innerFoundMember != "undefined") {
                                                                if (that.parsedFiles.hasOwnProperty(innerFoundMember.sourceFile)) {
                                                                    var hierarchyModules = that.getHierarchyDependenciesFromAstSync(innerFoundMember);
                                                                    hierarchyModules.reverse();
                                                                    
                                                                    for (fileIndex = 0; fileIndex < hierarchyModules.length; fileIndex++) {
                                                                        if (dependentFiles.indexOf(hierarchyModules[fileIndex]) == -1 && memberDependentFiles.indexOf(hierarchyModules[fileIndex]) == -1) {
                                                                            memberDependentFiles.splice(0, 0, hierarchyModules[fileIndex]);
                                                                        }
                                                                    }
                                                                }

                                                                if (dependentFiles.indexOf(innerFoundMember.sourceFile) == -1 && memberDependentFiles.indexOf(innerFoundMember.sourceFile) == -1) {
                                                                    memberDependentFiles.push(innerFoundMember.sourceFile);
                                                                }
                                                            }

                                                            nsIndex = 0;
                                                            ns = null;
                                                            innerFoundMember = undefined;
                                                        });
                                                    }
                                                }
                                            });

                                            memberDependentFiles.forEach(function (memberFile) {
                                                dependentFiles.push(memberFile);
                                            });
                                        }
                                    }
                                }
                            }

                            break;
                    }
                    break;
            }
        });
    },

    getHierarchyDependenciesFromAstSync: function (memberAst) {
        var baseAst = memberAst.inherits;
        var tempFullName = null;
        var tempParsedMember = null;
        var dependentFiles = [];

        if (typeof baseAst != "undefined") {
            do {
                tempFullName = baseAst.fullNamespaceName + "." + baseAst.name;

                // Maybe it's a member from a non-parsed file... (for example, built-in jOOPL types),
                // so they won't be in parsedMembers...
                if (this.parsedMembers.hasOwnProperty(tempFullName)) {
                    tempParsedMember = this.parsedMembers[tempFullName];
                    dependentFiles.push(tempParsedMember.sourceFile);

                    baseAst = tempParsedMember.hasOwnProperty("inherits") ? tempParsedMember.inherits : undefined;
                } else {
                    baseAst = undefined;
                }
            }
            while (typeof baseAst != "undefined");

            dependentFiles.reverse();
        }

        return dependentFiles;
    }
};

exports.Logger = Logger;
exports.DependencyAnalyzer = DependencyAnalyzer;
exports.DependencyMapBuilder = DependencyMapBuilder;