/*
 Copyright Matias Fidemraizer
 http://matiasfidemraizer.com
 http://www.linkedin.com/in/mfidemraizer/en

 jOOPL Dependency Analyzer
 https://github.com/mfidemraizer/joopl

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

var fs = require("fs");
var q = require("q");
var walk = require("walk");
var underscore = require("underscore");
var esprima = require("esprima");
var colors = require("colors");
var path = require("path");
var jsBeautify = require("js-beautify").js_beautify;

var Logger = function() {};

Logger.prototype = {
    logAlways: function(text, formatArgs) {
        if(typeof formatArgs == "undefined") {
            console.log(text);
        } else {
            console.log(text, formatArgs);
        }
    },

    logInfo: function(text, formatArgs) {
        if(Logger.enabled) {
            if(typeof formatArgs == "undefined") {
                console.log(text);
            } else {
                console.log(text, formatArgs);
            }
        }
    },

    logWarning: function(text, formatArgs) {
        if(Logger.enabled) {
            if(typeof formatArgs == "undefined") {
                console.log(text.yellow);
            } else {
                console.log(text.yellow, formatArgs);
            }
        }
    },

    logError: function(text, formatArgs) {
        if(typeof formatArgs == "undefined") {
            console.log(text.red);
        } else {
            console.log(text.red, formatArgs);
        }
    },

    logSuccess: function(text, formatArgs) {
        if(Logger.enabled) {
            if(typeof formatArgs == "undefined") {
                console.log(text.green);
            } else {
                console.log(text.green, formatArgs);
            }
        }
    }
};

Object.defineProperty(Logger, "enabled", { value: true, writable: true, configurable: false });
Object.defineProperty(Logger, "default", { value: new Logger(), writable: false, configurable: false });

var DependencyAnalyzer = function() { };

DependencyAnalyzer.prototype = {
    start: function(args) {
        var that = this;

        this.loadFilesAsync(args.baseDirectory).then(function(sourceFiles) {
            var mapBuilder = new DependencyMapBuilder();
            that._map = mapBuilder.buildAsync(sourceFiles, args.baseDirectory);
        });
    },

    get map() { 
        return this._map;
    },

    loadFilesAsync: function(baseUri) {
        var deferred = q.defer();
        var sourceFiles = [];

        var walker  = walk.walk(baseUri, { followLinks: false });

        walker.on("file", function(root, stat, next) {
            if(stat.name.indexOf("moduleinfo.js") == -1 && path.extname(stat.name) == ".js") {
                sourceFiles.push(root + '/' + stat.name);
            }
            
            next();
        });

        walker.on("end", function() {
            deferred.resolve(sourceFiles);
        });

        return deferred.promise;
    }
};

var DependencyMapBuilder = function() {
    this._parsedFiles = {};
    this._parsedMembers = {};
    this._newInstanceRegex = /new [a-z0-9.]+\.[a-z0-9]+/mig;
    this._newInstanceMemberNameRegex = /new [a-z0-9]+\./mig;
    this._newGlobalInstanceRegex = /new\s+\$global\.(?:[a-z0-9]+\.)+(?:[a-z0-9]+).+;$/mig;
};

DependencyMapBuilder.prototype = {
    get parsedFiles() {
        return this._parsedFiles;
    },

    get parsedMembers() {
        return this._parsedMembers;
    },

    get newInstanceRegex() {
        // This is important since this regexp has the global modifier
        // and this means last search will leave the index where something
        // was found for the next search...
        this._newInstanceRegex.lastIndex = 0;

        return this._newInstanceRegex;
    },

    get newInstanceMemberNameRegex() {
        this._newInstanceMemberNameRegex.lastIndex = 0;
        return this._newInstanceMemberNameRegex;
    },

    get newGlobalInstanceRegex() {
        this._newGlobalInstanceRegex.lastIndex = 0;
        return this._newGlobalInstanceRegex;
    },

    buildAsync: function (sourceFiles, baseDirectory) {
        var that = this;
        var namespaces = {};

        sourceFiles.forEach(function(sourceFile) {
            try {
                var parsedNamespaces = that.parseSourceFileSync(sourceFile);
                var namespaceFullNames = Object.keys(parsedNamespaces);
                var tempFullName = null;
                var tempNs = null;

                for(var nsIndex in namespaceFullNames) {
                    tempFullName = namespaceFullNames[nsIndex];
                    tempNs = parsedNamespaces[tempFullName];

                    if(!namespaces.hasOwnProperty(tempFullName)) {
                        namespaces[tempFullName] = tempNs;
                    }

                    for(var memberIndex in tempNs.members) {
                        if(namespaces[tempFullName].members.indexOf(tempNs.members[memberIndex]) == -1) {
                            namespaces[tempFullName].members.push(tempNs.members[memberIndex]);
                        }

                        that.parsedMembers[tempFullName + "." + tempNs.members[memberIndex].name] = tempNs.members[memberIndex];
                    }
                }

                Logger.default.logSuccess("Parsing file '" + sourceFile + "' succeded");
            } catch(e) {
                Logger.default.logError("Parsing file '" + sourceFile + "' failed (reason: '" + e.toString() + "')");
            }
        });

        var fileDependencyMaps = this.buildUsageMapSync(namespaces, sourceFiles);
        var finalResultJsSource = "$import.mapMany(" + JSON.stringify(fileDependencyMaps) + ");";

        fs.writeFileSync(
            path.join(baseDirectory, "moduleinfo.js"), 
            jsBeautify(finalResultJsSource, {
                "indent_size": 4,
                "indent_char": " ",
                "indent_level": 0,
                "indent_with_tabs": true,
                "preserve_newlines": true,
                "max_preserve_newlines": 10,
                "jslint_happy": true,
                "brace_style": "expand",
                "keep_array_indentation": false,
                "keep_function_indentation": false,
                "space_before_conditional": true,
                "break_chained_methods": false,
                "eval_code": false,
                "unescape_strings": false,
                "wrap_line_length": 40
            }), 
            { encoding: "utf8" }
        );
    },

    parseSourceFileSync: function(sourceFile) {
        var ast = esprima.parse(fs.readFileSync(sourceFile, 'utf8'), { range: true }).body;
        this.parsedFiles[sourceFile] = ast;

        return this.parseAstSync(sourceFile, ast);
    },

    parseAstSync: function(sourceFile, ast, namespaces) {
        var isFirstCall = !namespaces;
        var that = this;
        var namespaces = namespaces ? namespaces : {};

        ast.forEach(function(node) {
            switch(node.type) {
                case "FunctionExpression": 
                    that.parseAstSync(sourceFile, node.body.body, namespaces);
                    break;

                case "ExpressionStatement":
                    if(node.expression.type == "CallExpression" && node.expression.callee) {
                        var callee = node.expression.callee;
                        var arguments = node.expression.arguments;

                        switch(callee.type) {
                            // When it's a self-invoked function
                            case "FunctionExpression":
                                that.parseAstSync(sourceFile, callee.body.body, namespaces);
                                break;

                                // When it's some instance method call
                            case "MemberExpression":
                                if(typeof callee.object != "undefined")
                                {
                                    if(callee.object.name == "$import" && callee.property.name == "modules") {
                                        that.parseAstSync(sourceFile, [arguments[1]], namespaces);
                                    }
                                    // When registering a new namespace...
                                    else if(callee.object.name == "$namespace" && callee.property.name == "register") {
                                        var namespacePath = arguments[0].value;
                                        var namespaceScope = null;

                                        // Has scope function?
                                        if(arguments.length > 1) {
                                            namespaceScope = arguments[1].body.body;
                                        }

                                        // Isn't this namespace path already detected?
                                        if(!namespaces.hasOwnProperty(namespacePath)) {
                                            namespaces[namespacePath] = {
                                                fullName: namespacePath,
                                                name: namespacePath.split(".").pop(),
                                                members: []
                                            };
                                        }

                                        if(namespaceScope != null) {
                                            that.parseNamespaceScopeAstSync(namespaceScope, namespaces[namespacePath], sourceFile);
                                        }
                                    }
                                }
                                break;
                        }
                    }

                    break;
            }
        });

        return isFirstCall ? namespaces : null;
    },

    parseNamespaceScopeAstSync: function(ast, namespace, sourceFile) {
        var that = this;

        ast.forEach(function(node) {
            switch(node.type) {
                case "ExpressionStatement":
                    switch(node.expression.type) {
                        case "CallExpression":
                            var callee = node.expression.callee;

                            if(callee.type == "MemberExpression") {
                                var condition = callee.object.type == "ThisExpression"
                                                || 
                                                (
                                                    typeof node.expression.object != "undefined" && 
                                                    node.expression.object.type == "Identifier" && 
                                                    node.expression.object.name == namespace.fullName
                                                );

                                if(condition) {
                                    var arguments = node.expression.arguments;
                                    var declaration = arguments[0].value;
                                    var declarationOptions = arguments[1].properties;

                                    if(callee.property.name == "declareClass") {
                                        var member = {
                                            type: "class",
                                            name: arguments[0].value,
                                            parentNamespace: namespace,
                                            sourceFile: sourceFile,
                                        };

                                        namespace.members.push(member);

                                        // Gets class declaration parameters
                                        var options = that.parseClassDeclarationOptionsSync(declarationOptions, namespace);

                                        // Has inheritance?
                                        if(options.hasOwnProperty("inherits")) {
                                            member.inherits = options.inherits;
                                        }

                                    } else if(callee.property.name == "declareEnum") {
                                        var member = {
                                            type: "enum",
                                            name: arguments[0].value,
                                            parentNamespace: namespace,
                                            sourceFile: sourceFile,
                                        };

                                        namespace.members.push(member);
                                    }
                                }

                            }

                            break;
                    }
                    break;
            }
        });
    },

    parseClassDeclarationOptionsSync: function(options, namespace) {
        var result = {};
        var that = this;

        options.forEach(function(option) {
            if(option.type == "Property") {
                switch(option.key.name) {
                    case "inherits": 
                        var baseClass = null;

                        if(option.value.type == "MemberExpression") {
                            switch(option.value.object.type) {
                                case "ThisExpression":
                                    baseClass = { fullNamespaceName: namespace.fullName, name: option.value.property.name };
                                    break;

                                case "Identifier": 
                                    var nsPath = namespace.fullName.split(".");

                                    if(option.value.object.name == nsPath[nsPath.length - 1]) {
                                        baseClass = { fullNamespaceName: namespace.fullName, name: option.value.property.name };
                                    }
                                    break;

                                case "MemberExpression":
                                    var baseClass = that.getFullObjectNameFromAstSync(option.value);
                                    break;

                            }
                        }

                        if(baseClass != null) {
                            result.inherits = baseClass;
                        }
                        break;
                }
            }
        });

        return result;
    },

    getFullObjectNameFromAstSync: function(memberExpressionAst) {
        var lastExpr = memberExpressionAst;
        var fullName = [];

        while(typeof lastExpr !== "undefined") {
            if(lastExpr.type != "Identifier") {
                fullName.push(lastExpr.property.name);
                lastExpr = lastExpr.object;
            } else {
                lastExpr = undefined;
            }
        }

        if(fullName.length > 0) {
            var className = fullName[0];

            fullName.splice(0, 1);
            fullName.reverse();

            return { fullNamespaceName: fullName.join("."), name: className };
        } else {
            return null;
        }
    },

    buildUsageMapSync: function(namespaces) {
        var that = this;

        var dependentFiles = {}

        Object.keys(this.parsedFiles).forEach(function(parsedFile) {
            try {
                var ast = that.parsedFiles[parsedFile];

                dependentFiles[parsedFile] = [];
                that.getDependentFilesFromAstSync(parsedFile, ast, namespaces, dependentFiles[parsedFile]);

                Logger.default.logSuccess("Detecting dependencies from file '" + parsedFile + "' succeded");
            } catch(e) {
                Logger.default.logError("Detecting dependencies from file '" + parsedFile + "' failed (reason: '" + e.toString() + "')");
            }
        });

        Object.keys(dependentFiles).forEach(function(uri) {
            try
            {
                var files = dependentFiles[uri].concat();

                dependentFiles[uri].forEach(function(fileName) {
                    var result = [];
                    var ast = that.parsedFiles[fileName];

                    that.getDependentFilesFromAstSync(fileName, ast, namespaces, result);

                    var indexOfFile = files.indexOf(fileName);

                    result.forEach(function(detectedFile) {
                        if(files.indexOf(detectedFile) == -1) {
                            files.push(detectedFile);
                            indexOfFile++;
                        }
                    });
                });

                dependentFiles[uri] = files;
            } catch(e) {
                Logger.default.logError("Detecting dependencies from file '" + uri + "' failed (reason: '" + e.toString() + "')");
            }
        });

        var finalResult = {};

        Object.keys(dependentFiles).forEach(function(fullFileName) {
            var member = underscore.find(that.parsedMembers, function(member) { return member.sourceFile == fullFileName; } );

            finalResult[member.parentNamespace.fullName + "." + member.name]  = dependentFiles[fullFileName];
        });

        return finalResult;
    },

    getDependentFilesFromAstSync: function(parsedFile, ast, namespaces, dependentFiles) {
        var that = this;

        ast.forEach(function(node) {
            switch(node.type) {
                case "FunctionExpression":
                    that.getDependentFilesFromAstSync(parsedFile, node.body.body, namespaces, dependentFiles);
                    break;

                case "ExpressionStatement":
                    if(node.expression.type == "CallExpression" && node.expression.callee) {
                        var callee = node.expression.callee;
                        var arguments = node.expression.arguments;

                        switch(callee.type) {
                            // When it's a self-invoked function
                            case "FunctionExpression":
                                that.getDependentFilesFromAstSync(parsedFile, callee.body.body, namespaces, dependentFiles);
                                break;

                                // When it's some instance method call
                            case "MemberExpression":
                                if(typeof callee.object != "undefined")
                                {
                                    if(callee.object.name == "$import" && callee.property.name == "modules") {
                                        that.getDependentFilesFromAstSync(parsedFile, [arguments[1]], namespaces, dependentFiles);
                                    }
                                    // When registering a new namespace...
                                    else if(callee.object.name == "$namespace" && (callee.property.name == "using" || callee.property.name == "register")) {
                                        var scopeNamespaces = [];

                                        // If it's an using with mulitple imported namespaces with an array of string...
                                        if(callee.property.name == "using" && arguments.type == "ArrayExpression") {
                                            var elements = arguments[0].elements;

                                            // ..add each namespace to scope...
                                            elements.forEach(function(ns) {
                                                if(ns.type == "Literal") {
                                                    scopeNamespaces.push(namespaces[ns.value]);
                                                }
                                            });
                                        } else {
                                            scopeNamespaces.push(namespaces[arguments[0].value]);
                                        }

                                        var namespaceScopeAst = null;

                                        // Has scope function?
                                        if(arguments.length > 1) {
                                            namespaceScopeAst = arguments[1].body.body;
                                        }

                                        if(namespaceScopeAst != null) {
                                            that.detectMembersFromNamespaceScopeSync(parsedFile, namespaceScopeAst, scopeNamespaces, namespaces, dependentFiles);
                                        }
                                    }
                                }
                                break;
                        }
                    }

                    break;
            }
        });
    },

    detectMembersFromNamespaceScopeSync: function(parsedFile, namespaceScopeAst, scopeNamespaces, namespaces, dependentFiles) { 
        var that = this;
        var parsedFileContents = fs.readFileSync(parsedFile, "utf8");

        namespaceScopeAst.forEach(function(node) {
            switch(node.type) {
                case "ExpressionStatement":
                    switch(node.expression.type) {
                        case "CallExpression":
                        case "NewExpression":
                            var callee = node.expression.callee;

                            if(callee.type == "MemberExpression") {
                                var condition = callee.object.type == "ThisExpression"
                                                || 
                                                (
                                                    typeof node.expression.object != "undefined" && 
                                                    node.expression.object.type == "Identifier" && 
                                                    node.expression.object.name == namespace.fullName
                                                );

                                if(condition) {
                                    var arguments = node.expression.arguments;
                                    var memberName = null;

                                    if(callee.property.name == "declareClass" || callee.property.name == "declareEnum") {
                                        memberName = arguments[0].value;
                                    } else {
                                        memberName = callee.property.name;
                                    }

                                    var memberFound = false;
                                    var nsIndex = 0;
                                    var ns = null;
                                    var foundMember = undefined;

                                    while(typeof foundMember == "undefined" && nsIndex < scopeNamespaces.length) {
                                        ns = scopeNamespaces[nsIndex];

                                        foundMember = underscore.findWhere(ns.members, { name: memberName });
                                        nsIndex++;
                                    }

                                    if(typeof foundMember != "undefined") {
                                        if(foundMember.hasOwnProperty("inherits")) {
                                            var files = that.getHierarchyDependenciesFromAstSync(foundMember);

                                            for(var fileIndex = 0; fileIndex < files.length; fileIndex++) {
                                                if(dependentFiles.indexOf(files[fileIndex]) == -1) {
                                                    dependentFiles.push(files[fileIndex]);
                                                }
                                            }
                                        }

                                        if(dependentFiles.indexOf(foundMember.sourceFile) == -1) {
                                            dependentFiles.push(foundMember.sourceFile);
                                        }
                                    }

                                    if(arguments.length == 2 && arguments[1].hasOwnProperty("properties")) {
                                        var declarationOptions = {};

                                        arguments[1].properties.forEach(function(arg) {
                                            declarationOptions[arg.key.name] = arg.value;
                                        });

                                        var hasMembers = declarationOptions.hasOwnProperty("members");

                                        // Class constructor will be treated like a regular class member
                                        if(declarationOptions.hasOwnProperty("ctor") && declarationOptions.ctor.type == "FunctionExpression") {
                                            // This simulates a Esprima syntax tree node
                                            var ctor = {
                                                key: {
                                                    type: "Identifier",
                                                    name: "ctor"
                                                },
                                                value: declarationOptions.ctor
                                            };

                                            if(!hasMembers) {
                                                declarationOptions.members = {
                                                    type: "ObjectExpression",
                                                    properties: [ctor]
                                                };

                                                hasMembers = true;
                                            } else {
                                                declarationOptions.members.properties.push(ctor);
                                            }
                                        }

                                        if(hasMembers && declarationOptions.members.type == "ObjectExpression") {
                                            var classMembers = declarationOptions.members.properties;

                                            var memberDependentFiles = [];

                                            classMembers.forEach(function(memberAst) {
                                                if(memberAst.value.type == "FunctionExpression") {
                                                    var memberContent = parsedFileContents.substring(memberAst.value.body.range[0], memberAst.value.body.range[1]);

                                                    var newInstances = that.newInstanceRegex.exec(memberContent);
                                                    var newGlobalInstances = that.newGlobalInstanceRegex.exec(memberContent);
                                                    
                                                    var result = newInstances;

                                                    if(newGlobalInstances != null) {
                                                        if(newInstances != null) {
                                                            result = result.concat(newGlobalInstances);
                                                        } else {
                                                            result = newGlobalInstances;
                                                        }
                                                    }

                                                    if(result != null) {
                                                        var nsIndex = 0;
                                                        var ns = null;
                                                        var foundMember = undefined;
                                                        var tempMemberName;
                                                        var tempModuleName;

                                                        result.forEach(function(newExpressionText) {
                                                            switch(newExpressionText.indexOf("$global")) {
                                                                case -1:
                                                                    tempMemberName = newExpressionText.replace(that.newInstanceMemberNameRegex, "");
                                                                    break;

                                                                default:
                                                                    tempMemberName = newExpressionText.substring(
                                                                        newExpressionText.indexOf(".") + 1,
                                                                        newExpressionText.indexOf("(")
                                                                    );

                                                                    tempMemberName = tempMemberName.replace(" ", "");
                                                                    tempMemberName = tempMemberName.replace("$global.", "");

                                                                    if(that.parsedMembers.hasOwnProperty(tempMemberName)) {
                                                                        foundMember = that.parsedMembers[tempMemberName];
                                                                    }

                                                                    break;
                                                            }

                                                            while(typeof foundMember == "undefined" && nsIndex < scopeNamespaces.length) {
                                                                ns = scopeNamespaces[nsIndex];

                                                                foundMember = underscore.findWhere(ns.members, { name: tempMemberName });
                                                                nsIndex++;
                                                            }

                                                            if(typeof foundMember != "undefined") {
                                                                if(that.parsedFiles.hasOwnProperty(foundMember.sourceFile)) {
                                                                    var hierarchyModules = that.getHierarchyDependenciesFromAstSync(foundMember);

                                                                    for(var fileIndex = 0; fileIndex < hierarchyModules.length; fileIndex++) {
                                                                        if(dependentFiles.indexOf(hierarchyModules[fileIndex]) == -1 && memberDependentFiles.indexOf(hierarchyModules[fileIndex]) == -1) {
                                                                            memberDependentFiles.push(hierarchyModules[fileIndex]);
                                                                        }
                                                                    }
                                                                }

                                                                if(dependentFiles.indexOf(foundMember.sourceFile) == -1 && memberDependentFiles.indexOf(foundMember.sourceFile) == -1) {
                                                                    memberDependentFiles.push(foundMember.sourceFile);
                                                                }
                                                            }

                                                            nsIndex = 0;
                                                            ns = null;
                                                            foundMember = undefined;
                                                        });
                                                    }
                                                }
                                            });

                                            memberDependentFiles.forEach(function(memberFile) {
                                                dependentFiles.push(memberFile);
                                            });
                                        }
                                    }
                                }
                            }

                            break;
                    }
                    break;
            }
        });
    },

    getHierarchyDependenciesFromAstSync: function(memberAst) {
        var baseAst = memberAst.inherits;
        var tempFullName = null;
        var tempParsedMember = null;
        var dependentFiles = [];

        do {
            tempFullName = baseAst.fullNamespaceName + "." + baseAst.name;

            // Maybe it's a member from a non-parsed file... (for example, built-in jOOPL types),
            // so they won't be in parsedMembers...
            if(this.parsedMembers.hasOwnProperty(tempFullName)) {
                tempParsedMember = this.parsedMembers[tempFullName];
                dependentFiles.push(tempParsedMember.sourceFile);

                baseAst = tempParsedMember.hasOwnProperty("inherits") ? tempParsedMember.inherits : undefined;
            } else {
                baseAst = undefined;
            }
        }
        while(typeof baseAst != "undefined");

        dependentFiles.reverse();

        return dependentFiles;
    }   
};

exports.Logger = Logger;
exports.DependencyAnalyzer = DependencyAnalyzer;
exports.DependencyMapBuilder = DependencyMapBuilder;