<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>jOOPL: joopl.js - { joopl };</title>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
   <!-- <script src="../assets/../api.js"></script>
    <script src="../assets/js/api-filter.js"></script>
    <script src="../assets/js/api-list.js"></script>
    <script src="../assets/js/api-search.js"></script>
    <script src="../assets/js/apidocs.js"></script>-->
</head>
<body class="yui3-skin-sam">
    <a href="https://github.com/you"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 9999" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

<div id="doc">
    <div id="hd" class="yui3-g header" style="display: none">
        <div class="yui3-u-3-4">
            
                <h1><img src="https://download-codeplex.sec.s-msft.com/Download?ProjectName=joopl&amp;DownloadId=652315&amp;Build=20425" title="{ joopl };"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div id="sidebar-container" class="yui3-u-1-4">
            
                <img id="project-logo" src="https://download-codeplex.sec.s-msft.com/Download?ProjectName=joopl&amp;DownloadId=652315&amp;Build=20425" title="{ joopl };" onclick="window.location='../index.html'"/>
            
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">> Object-oriented programming</h2>
    <ol id="oop-hints">
        <li><a href="../classes/$namespace.html#method_register" target="_self">Registering namespaces how-to</a></li>
        <li><a href="../classes/$namespace.html#method_using" target="_self">Importing namespaces</a></li>
        <li><a href="../classes/$namespace.html#namespace-global" target="_self">$global namespace</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-define" target="_self">Define a class how-to</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-constructors" target="_self">Class constructors</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-properties" target="_self">Class properties</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-methods" target="_self">Class methods</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-events" target="_self">Custom events how-to</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-instances" target="_self">Creating class instances how-to</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-inheritance" target="_self">Class inheritance how-to</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#class-polymorphism" target="_self">Class polymorphism how-to</a></li>
        <li><a href="../classes/Define%20classes%20with%20jOOPL.html#type-metadata" target="_self">Type metadata</a></li>
        <li><a href="../classes/Declaring%20enumerations%20with%20jOOPL.html#index" target="_self">Enumerations</a></li>
        <li><a href="../classes/joopl.Attribute.html#index" target="_self">Custom metadata: attributes</a></li>
        <li><a href="../classes/Exception%20throwing%20best%20practices.html" target="_self">Throwing exceptions best practice</a></li>
    </ol>

    <h2 class="off-left">> Tests</h2>
    <ol id="oop-hints">
        <li><a href="../test/namespace.test.html" target="_self">Namespace tests</a></li>
        <li><a href="../test/class.test.html" target="_self">Class tests</a></li>
        <li><a href="../test/enum.test.html" target="_self">Enumeration tests</a></li>
    </ol>

    <h2 class="off-left">> API reference</h2>
    <ol id="class-list"> 
        <li><a href="../classes/joopl.Object.html" target="_self"><strong>joopl.Object</strong></a></li>
        <li><a href="../classes/joopl.Attribute.html" target="_self"><strong>joopl.Attribute</strong></a></li>
        <li><a href="../classes/joopl.Enum.html" target="_self"><strong>joopl.Enum</strong></a></li>
        <li><a href="../classes/joopl.EnumValue.html" target="_self"><strong>joopl.EnumValue</strong></a></li>
        <li><a href="../classes/joopl.Type.html" target="_self"><strong>joopl.Type</strong></a></li>
        <li><a href="../classes/joopl.Exception.html" target="_self"><strong>joopl.Exception</strong></a></li>
        <li><a href="../classes/joopl.ArgumentException.html" target="_self"><strong>joopl.ArgumentException</strong></a></li>
        <li><a href="../classes/joopl.NotImplementedException.html" target="_self"><strong>joopl.NotImplementedException</strong></a></li>
    </ol>

    <h2 class="off-left">> Quick links</h2>
    <ol id="quick-links">
        <li><a href="https://groups.google.com/forum/#!forum/joopl" target="_blank">jOOPL Google Group</a></li>
        <li><a href="https://github.com/mfidemraizer/joopl" target="_blank">jOOPL on GitHub</a></li>
        <li><a href="http://cdn.jsdelivr.net/joopl/2.4.0/joopl.min.js" target="_blank"><strong>Download minified jOOPL 2.4.0 (CDN)</strong></a></li>
        <li><a href="https://github.com/mfidemraizer/joopl/issues" target="_blank">Issue tracker</a></li>
    </ol>

    <div id="api-tabview" class="tabview" style="display: none">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/$namespace.html">$namespace</a></li>
            
                <li><a href="../classes/Declaring enumerations with jOOPL.html">Declaring enumerations with jOOPL</a></li>
            
                <li><a href="../classes/Define classes with jOOPL.html">Define classes with jOOPL</a></li>
            
                <li><a href="../classes/Exception throwing best practices.html">Exception throwing best practices</a></li>
            
                <li><a href="../classes/joopl.ArgumentException.html">joopl.ArgumentException</a></li>
            
                <li><a href="../classes/joopl.Attribute.html">joopl.Attribute</a></li>
            
                <li><a href="../classes/joopl.Enum.html">joopl.Enum</a></li>
            
                <li><a href="../classes/joopl.EnumValue.html">joopl.EnumValue</a></li>
            
                <li><a href="../classes/joopl.Environment.html">joopl.Environment</a></li>
            
                <li><a href="../classes/joopl.Exception.html">joopl.Exception</a></li>
            
                <li><a href="../classes/joopl.Namespace.html">joopl.Namespace</a></li>
            
                <li><a href="../classes/joopl.NotImplementedException.html">joopl.NotImplementedException</a></li>
            
                <li><a href="../classes/joopl.Object.html">joopl.Object</a></li>
            
                <li><a href="../classes/joopl.Type.html">joopl.Type</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: joopl.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
// (c) joopl 
// By Matï¿½as Fidemraizer (http://www.matiasfidemraizer.com) (http://www.linkedin.com/in/mfidemraizer/en)
// -------------------------------------------------
// Project site on GitHub: http://mfidemraizer.github.io/joopl/
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Keywords
var $namespace = null; // Holds an object to manage namespaces
var $global = null; // Represents the global scope.
var $manifest = null;

(function (undefined) {
    &quot;use strict&quot;;

    var version = &quot;2.4.0&quot;;
    var $enumdef = null;
    var $def = null;

    /** 
        Represents a namespace which can declare classes and enumerations, and provides metadata.

        @class Namespace
        @constructor
    */
    var Namespace = function (args) {

        /**
            Gets namespace name

            @property name
            @type string
        */
        Object.defineProperty(
            this,
            &quot;name&quot;, {
                value: args.name,
                writable: false,
                configurable: false,
                enumerable: true
            }
        );

        /**
            Gets namespace full namespace path

            @property fullName
            @type string
        */
        Object.defineProperty(
            this,
            &quot;fullName&quot;, {
                value: args.fullName,
                writable: false,
                configurable: false,
                enumerable: true
            }
        );

        /**
            Gets the parent namespace object

            @property parent
            @type Namespace
        */
        Object.defineProperty(
            this,
            &quot;parent&quot;, {
                value: args.parent,
                writable: false,
                configurable: false,
                enumerable: true
            }
        );

        /**
            Declares a class inside the namespace (see &lt;a href=&quot;define classes with joopl.html&quot; target=&quot;_self&quot;&gt;how to define classes&lt;/a&gt;)

            @method declareClass
            @param {string} className A class name (f.e. &quot;MyClass&quot;, &quot;Person&quot;, &quot;Order&quot;, &quot;Product&quot;...)
            @param {object} classDef A class definition 
        */
        Object.defineProperty(
            this,
            &quot;declareClass&quot;, {
                value: function (className, classDef) {
                    Object.defineProperty(
                        this,
                        className, {
                            value: $def(className, this, classDef),
                            writable: false,
                            configurable: false,
                            enumerable: true
                        }
                    );
                },
                writable: false,
                enumerable: true,
                configurable: false
            }
        );

        Object.defineProperty(
            this,
            &quot;declareEnum&quot;, {
                value: function (name, enumDef) {
                    Object.defineProperty(
                        this,
                        name, {
                            value: $enumdef(name, this, enumDef),
                            writable: false,
                            configurable: false,
                            enumerable: true
                        }
                    );
                },
                writable: false,
                enumerable: true,
                configurable: false
            }
        );
    };

    Object.freeze(Namespace);

    $global = new Namespace({ name: &quot;$global&quot;, fullName: &quot;$global&quot;, parent: null });

    // An object containing a set of core features used by jOOPL
    var TypeUtil = {
        //  Creates a property on the given class definition based on a provided property descriptor.
        // @classDef: The class definition (it must be the ctor function!
        // @name: The property name
        // @descriptor: An object representing the property descriptor
        // @context: An optional context object that will work as the &quot;this&quot; keyword binder for the getter and/or setter when defining the property.
        createPropertyFromDescriptor: function (classDef, name, descriptor, context) {
            if (context) {
                if (descriptor.get) {
                    descriptor.get = descriptor.get.bind(context);
                }

                if (descriptor.set) {
                    descriptor.set = descriptor.set.bind(context);
                }
            }

            Object.defineProperty(
                context ? context : classDef.prototype,
                name,
                descriptor
            );
        },

        // Creates a property.
        // @classDef: A class definition (it must be the class ctor function).
        // @name: The property name.
        // @getter: The getter parameterless function.
        // @setter: The setter function with a parameter representing the value to set.
        // @inmutable: A boolean flag specifying if the created property is configurable or not.
        createProperty: function (classDef, name, getter, setter, inmutable) {
            if (inmutable == undefined) {
                inmutable = false;
            }

            if (!classDef.prototype.hasOwnProperty(name)) {
                // This case is for a read-write property
                if (getter &amp;&amp; setter) {

                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            get: getter,
                            set: setter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                } else if (getter) { // This case is for a read-only property
                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            get: getter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                } else if (setter) { // This case is for a write-only property
                    Object.defineProperty(
                        classDef.prototype,
                        name, {
                            set: setter,
                            configurable: !inmutable,
                            enumerable: true
                        }
                    );
                }
            }
        },

        createEvent: function (source, name) {
            if (source.hasOwnProperty(name)) {
                throw Error(&quot;The source object has already defined an event called &#x27;&quot; + name + &quot;&#x27;&quot;);
            }
            var eventManager = new $global.joopl.EventManager({ source: source });

            Object.defineProperty(
                source,
                name,
                {
                    get: function () {
                        return eventManager[name];
                    },
                    set: function (value) {
                        eventManager[name] = value;
                    },
                    configurable: false,
                    enumerable: true
                }
            );

            eventManager.register(name);
        },

        // Builds a class instance into a full jOOPL object supporting inheritance and polymoprhism, and calls the ctor of the whole class instance.
        // @instance: The class instance
        // @args: The ctor arguments.
        buildObject: function (instance, args, callctor) {
            if (typeof instance.base == &quot;function&quot;) {
                Object.defineProperty(
                    instance,
                    &quot;base&quot;,
                    {
                        value: new instance.base(args, false),
                        writable: false,
                        configurable: false,
                        enumerable: false
                    }
                );

                Object.defineProperty(
                    instance,
                    &quot;_&quot;, {
                        value: instance.base._,
                        writable: false,
                        configurable: false,
                        enumerable: false
                    }
                );
            } else {

                Object.defineProperty(
                    instance,
                    &quot;_&quot;, {
                        value: {},
                        writable: false,
                        configurable: false,
                        enumerable: false
                    }
                );
            }

            if (callctor) {
                instance.ctor.call(instance, args);
            }


            Object.defineProperty(
                instance._,
                &quot;derived&quot;, {
                    value: instance,
                    writable: false,
                    configurable: true,
                    enumerable: false
                }
            );

            return instance;
        },

        // Builds a given class inheritance with the given parent class.
        // @derived: The child class.
        // @parent: The parent class.
        buildInheritance: function (derived, parent) {
            if (parent != null) {
                // Adding all class fields to the derived class...
                for (var fieldName in parent.prototype._) {
                    if (!derived.prototype._[fieldName]) {
                        Object.defineProperty(
                            derived.prototype._,
                            fieldName, {
                                value: parent.prototype._[fieldName],
                                writable: true,
                                configurable: false,
                                enumerable: true
                            }
                        );
                    }
                }

                var propertyDescriptor = null;

                // Adding both methods and properties to the derived class...
                for (var memberName in parent.prototype) {
                    if (!derived.prototype.hasOwnProperty(memberName) &amp;&amp; !$global.joopl.Object.prototype.hasOwnProperty(memberName)) {
                        propertyDescriptor = Object.getOwnPropertyDescriptor(parent.prototype, memberName);

                        // If it has a property descriptor...
                        if (propertyDescriptor) {
                            // and the value of the descriptor is a function it means that it&#x27;s inheriting a method.
                            if (typeof propertyDescriptor.value == &quot;function&quot;) {
                                Object.defineProperty(
                                    derived.prototype,
                                    memberName, {
                                        value: parent.prototype[memberName],
                                        writable: false,
                                        enumerable: true,
                                        configurable: true
                                    }
                                );
                                // derived.prototype[memberName] = parent.prototype[memberName];
                            } else { // If not, it is a property accessor.
                                this.createPropertyFromDescriptor(derived, memberName, propertyDescriptor);
                            }
                        } else if (typeof parent.prototype[memberName] == &quot;function&quot;) { // It can also happen that it&#x27;s a function defined in the $global.joopl.Object prototype...
                            Object.defineProperty(
                                derived.prototype,
                                memberName, {
                                    value: parent.prototype[memberName],
                                    writable: false,
                                    enumerable: true,
                                    configurable: false
                                }
                            );
                        }
                    }
                }
            }

            return parent ? parent.prototype : null;
        },

        // Whether determines if some object reference has an associated value (object) and returns true/false.
        // @someRef: The object reference.
        hasValue: function (someRef) {
            return someRef !== undefined &amp;&amp; someRef != null;
        }
    };

    Object.freeze(TypeUtil);

    var DependencyUtil = {
        findFileInUsageMap: function (fileName) {
            var usageMap = $global.__DependencyUsageMap;
            var found = false;
            var index = 0;

            while (!found &amp;&amp; index &lt; usageMap.length) {
                if (usageMap[index].fileName == fileName) {
                    found = true;
                } else {
                    index++;
                }
            }

            if (found) {
                return usageMap[index];
            } else {
                return null;
            }
        },

        buildDependencyList: function (fileName) {
            var map = $global.__DependencyMap;
            var usageMap = $global.__DependencyUsageMap;

            var fileManifest = this.findFileInUsageMap(fileName);

            var dependencies = [];

            for (var manifestIndex = 0; manifestIndex &lt; fileManifest.dependsOn.length; manifestIndex++) {
                dependencies.add(fileManifest.dependsOn[manifestIndex]);
            }

        }
    };

    Object.freeze(DependencyUtil);

    $manifest = {
        file: function (executingFileName, scopeFunc) {
            var scopeMetadata = {
                executingFileName: executingFileName
            };

            var enableHeadJS = $global.__DependencyUsageMap !== undefined &amp;&amp; window.head != undefined &amp;&amp; window.head.js != undefined;

            scopeFunc = scopeFunc.bind(scopeMetadata);

            // If HeadJS is available, jOOPL integrates HeadJS asynchronous loading 
            // of DependencyUsageMap dependencies
            if (enableHeadJS) {
                var found = false;
                var index = 0;

                while (!found &amp;&amp; index &lt; $global.__DependencyUsageMap.length) {
                    if ($global.__DependencyUsageMap[index].fileName == executingFileName) {
                        found = true;
                    } else {
                        index++;
                    }
                }

                if (found) {
                    var args = $global.__DependencyUsageMap[index].dependsOn.splice(0);
                    args.push(function () {
                        scopeFunc();
                    });

                    head.js.apply(window, args);
                }
            } else {
                scopeFunc();
            }
        }
    };

    Object.freeze($manifest);

    $namespace = {
        register: function (path, scopedFunc) {
            var nsIdentifiers = typeof path == &quot;string&quot; ? path.split(&quot;.&quot;) : null;

            // The parent namespace of everything is the reserved $global object!
            var parentNs = $global;
            var currentNs = null;
            var nsPath = [];

            for (var nsIndex = 0; nsIndex &lt; nsIdentifiers.length; nsIndex++) {
                currentNs = nsIdentifiers[nsIndex];
                nsPath.push(currentNs);

                // The current namespace  is not registered (if evals true)
                if (!parentNs[currentNs]) {
                    Object.defineProperty(
                        parentNs,
                        currentNs, {
                            value: new Namespace({ parent: parentNs, name: currentNs, fullName: nsPath.join(&quot;.&quot;) }),
                            writable: false,
                            configurable: false,
                            enumerable: true
                        }
                    );
                }

                parentNs = parentNs[currentNs];
            }

            // If the second parameter holds something if should be a 
            // parameterless function, and this is creating a namespace scope.
            if (typeof scopedFunc == &quot;function&quot;) {
                $namespace.using(path, scopedFunc, true);
            }
        },

        /** 
            Aliases an existing namespace.

            @method alias
            @param namespace {Object} The namespace to alias
            @param alias {String} The alias
            @example
                $namespace.register(&quot;joopl.samples&quot;);
                $namespace.alias($global.joopl.samples, &quot;samples&quot;);
        */
        alias: function (namespace, alias) {
            $global[alias] = namespace;
        },

        /**
            Imports the members of given namespace path.

            The &#x60;$namespace.using&#x60; method will not register a namespace if a given namespace path is not previously registered with &#x60;$namespace.register&#x60;.

            @method using
            @param paths {Array} An array of strings of the namespaces to import
            @param scopedFunc {Function} A function to create a namespace scope (optional)
            @param scopeIsNs {boolean} USED BY THE SYSTEM. IT IS NOT RECOMMENDED FOR DEVELOPERS. A boolean flag specifying if the this keyword in the scoped function must be the childest namespace or not (optional)
        */
        using: function (paths, scopedFunc, scopeIsNs) {
            if (paths === undefined) {
                debugger;
                throw new $global.joopl.ArgumentException({ argName: &quot;namespace path&quot;, reason: &quot;No namespace path has been provided&quot; });
            }

            if (typeof paths == &quot;string&quot;) {
                if (paths.length == 0) {
                    debugger;
                    throw new $global.joopl.ArgumentException({ argName: &quot;namespace path&quot;, reason: &quot;No namespace path has been provided&quot; });
                }

                paths = [paths];
            }

            if (paths.length == 0) {
                debugger;
                throw new $global.joopl.ArgumentException({ argName: &quot;namespace path&quot;, reason: &quot;No namespace path has been provided&quot; });
            }

            var nsIdentifiers = null;
            var currentNs = $global;
            var nsIndex = 0;
            var namespaces = [];

            for (var pathIndex in paths) {
                nsIdentifiers = paths[pathIndex].split(&quot;.&quot;);

                for (nsIndex = 0; nsIndex &lt; nsIdentifiers.length; nsIndex++) {
                    currentNs = currentNs[nsIdentifiers[nsIndex]];

                    if (!currentNs) {
                        debugger;
                        throw new $global.joopl.ArgumentException({
                            argName: &quot;namespace path&quot;,
                            reason: &quot;The namespace path &#x27;&quot; + paths[pathIndex] + &quot;&#x27; is not valid because the namespace &#x27;&quot; + nsIdentifiers[nsIndex] + &quot;&#x27; is not declared&quot;
                        });
                    }
                }

                namespaces.push(currentNs);
                currentNs = $global;
            }

            var nsScope = {};
            var tempMember = null;

            for (nsIndex in namespaces) {
                for (var typeName in namespaces[nsIndex]) {
                    if (!nsScope[typeName]) {
                        tempMember = namespaces[nsIndex][typeName];

                        if ((tempMember.prototype !== undefined &amp;&amp; !tempMember.prototype.joopl !== undefined) || tempMember.joopl !== undefined) {
                            nsScope[typeName] = tempMember;
                        }
                    }
                    else {
                        throw Error(&quot;A type called &#x27;&quot; + typeName + &quot;&#x27; in current context from another namespace already exists. Create an alias or use a full namespace paths&quot;);
                    }
                }
            }

            Object.preventExtensions(nsScope);

            if (scopedFunc !== undefined &amp;&amp; typeof scopedFunc == &quot;function&quot;) {
                if (scopeIsNs) {
                    scopedFunc.bind(namespaces[nsIndex])();
                } else if (scopedFunc.length == 0) {
                    scopedFunc.bind(nsScope)();
                } else {
                    scopedFunc.bind($global)(nsScope);
                }

                return null;
            } else {
                return nsScope;
            }
        },
    };

    Object.freeze($namespace);


    $def = function (className, namespace, args) {
        var classDef = null;

        if (!args &amp;&amp; this) {
            args = this;
        }
        else if (!args &amp;&amp; !this) {
            args = {};
        }

        if (args.$inmutable === true &amp;&amp; Object.freeze) {
            classDef = function (args, callctor) {
                TypeUtil.buildObject(this, args, callctor === undefined);

                Object.freeze(this);
            };

        } else if (args.dynamic === false &amp;&amp; Object.preventExtensions) {
            classDef = function (args, callctor) {
                TypeUtil.buildObject(this, args, callctor === undefined);

                Object.preventExtensions(this);
            };

        } else {
            classDef = function (args, callctor) {
                TypeUtil.buildObject(this, args, callctor === undefined);
            };
        }

        classDef.prototype = new $global.joopl.Object();

        var ctor = null;

        if (args.ctor) {
            ctor = args.ctor;
        } else {
            ctor = function () { };
        }

        Object.defineProperty(
            classDef.prototype,
            &quot;ctor&quot;, {
                value: ctor,
                writable: false,
                configurable: false,
                enumerable: false
            }
        );

        if (args.members) {
            var propertyDescriptor = null;

            for (var memberName in args.members) {
                propertyDescriptor = Object.getOwnPropertyDescriptor(args.members, memberName);

                if (typeof propertyDescriptor.value == &quot;function&quot;) {
                    if (classDef.prototype.hasOwnProperty(memberName)) {
                        Object.defineProperty(
                            classDef.prototype,
                            memberName, {
                                value: args.members[memberName]
                            }
                        );
                    } else {
                        Object.defineProperty(
                            classDef.prototype,
                            memberName, {
                                value: args.members[memberName],
                                writable: false,
                                configurable: true,
                                enumerable: true
                            }
                        );
                    }
                } else if (memberName == &quot;events&quot; &amp;&amp; typeof propertyDescriptor.value == &quot;object&quot;) {
                    for (var eventIndex in propertyDescriptor.value) {
                        TypeUtil.createEvent(classDef.prototype, propertyDescriptor.value[eventIndex]);
                    }

                } else if (propertyDescriptor.hasOwnProperty(&quot;value&quot;) || propertyDescriptor.hasOwnProperty(&quot;get&quot;) || propertyDescriptor.hasOwnProperty(&quot;set&quot;)) {
                    TypeUtil.createPropertyFromDescriptor(classDef, memberName, propertyDescriptor);
                }
            }
        }


        if (args.inherits) {
            TypeUtil.buildInheritance(classDef, args.inherits);

            Object.defineProperty(
                classDef.prototype,
                &quot;base&quot;, {
                    value: args.inherits,
                    writable: false,
                    configurable: false,
                    enumerable: false
                }
            );
        }

        var hasMetadata = false;

        if (Array.isArray(args.attributes)) {
            for (var attrIndex in args.attributes) {
                if (!args.attributes[attrIndex] &amp;&amp; !(args.attributes[attrIndex].isTypeOf instanceof Function) &amp;&amp; !args.attributes[attrIndex].isTypeOf($global.joopl.Attribute)) {
                    debugger;
                    throw new $global.joopl.ArgumentException({
                        argName: &quot;attributes&quot;,
                        reason: &quot;A non-attribute type given as attribute&quot;
                    });
                }
            }

            hasMetadata = true;
        }

        if (typeof $global.joopl.Type == &quot;function&quot;) {
            var typeDescriptor = {
                configurable: true,
                enumerable: true,
                writable: false,
                value: new $global.joopl.Type({ name: className, baseType: args.inherits ? args.inherits.type : null, namespace: namespace, attributes: hasMetadata ? args.attributes : [] })
            };

            Object.defineProperty(classDef, &quot;type&quot;, typeDescriptor);
            Object.defineProperty(classDef.prototype, &quot;type&quot;, typeDescriptor);
        }

        return classDef;
    };

    Object.freeze($def);

    $namespace.register(&quot;joopl&quot;, function () {
        /**
            @namespace joopl
        */

        var scope = this;

        /** 
            Represents the base type of any class defined by jOOPL

            @class Object
            @constructor
        */
        this.Object = function () {
        };

        this.Object.prototype = {

            /**
                Gets jOOPL library version (f.e. &quot;2.4.0&quot;)

                @property joopl
                @type string
                @readonly
            */
            get joopl() { return version; },

            /**
                Determines if a given type is of type of current object

                @method isTypeOf
                @param {class} type The whole type to compare with
                @example obj.isTypeOf(this.A)
                
            */
            isTypeOf: function (type) {
                var allBases = [];
                var lastBase = this;
                var isMember = false;

                if (this instanceof type) {
                    isMember = true;
                } else {
                    while (!isMember &amp;&amp; lastBase.base) {
                        if (!(isMember = lastBase.base instanceof type)) {
                            lastBase = lastBase.base;
                        }
                    }
                }

                return isMember;
            }
        };

        /**
            Represents type information and provides access to types&#x27; metadata.

            @class Type
            @final
            @since 2.3.0
        */
        this.declareClass(&quot;Type&quot;, {
            ctor: function (args) {
                this._.attributes = args.attributes;
                this._.name = args.name;
                this._.namespace = args.namespace;
                this._.baseType = args.baseType;
            },
            members: {
                /**
                    Gets type name (f.e. &quot;MyClass&quot;)

                    @property name
                    @type string
                    @readonly
                */
                get name() {
                    return this._.name;
                },

                /**
                    Gets current type name including full namespace path (f.e. &quot;joopl.test.MyClass&quot;)

                    @property fullName
                    @type string
                    @readonly
                */
                get fullName() {
                    return this.namespace.fullName + &quot;.&quot; + this.name;
                },

                /**
                    Gets current base type (i.e. parent class) metadata.

                    @property baseType
                    @type joopl.Type
                    @readonly
                */
                get baseType() {
                    return this._.baseType;
                },

                /**
                    Gets current namespace instance

                    @property baseType
                    @type joopl.Namespace
                    @readonly
                */
                get namespace() {
                    return this._.namespace;
                },

                /**
                    Gets all type&#x27;s attributes.

                    @property attributes
                    @type joopl.Attribute
                    @readonly
                */
                get attributes() {
                    return this._.attributes;
                },

                /**
                    Gets an attribute instance by giving its type, if the type has the whole attribute

                    @method getAttribute
                    @param {joopl.Attribute} An attribute class definition (rather than an instance!)
                    @return {joopl.Attribute} The attribute instance or &#x60;null&#x60; if the type does not have the given attribute type
                    @example 
                        this.MyClass.type.getAttribute(this.MyAttribute);
                */
                getAttribute: function (attributeType) {
                    var found = false;
                    var index = 0;

                    while (!found &amp;&amp; index &lt; this.attributes.length) {
                        if (this.attributes[index] instanceof attributeType) {
                            found = true;
                        } else {
                            index++;
                        }
                    }

                    if (found) {
                        return this.attributes[index];
                    } else {
                        return null;
                    }
                },

                /**
                    Determines whether a given type has an attribute giving its class (rather than giving an instance!)

                    @method hasAttribute
                    @param {joopl.Attribute} The whole attribute class
                    @example
                        this.SomeClass.type.hasAttribute(SomeAttribute);
                */
                hasAttribute: function (attributeType) {
                    return this.getAttribute(attributeType) != null;
                }
            }
        });

        /**
            &lt;h2 id=&quot;index&quot;&gt;Index&lt;/h2&gt;

            * 1.0\. [What is an attribute?](#attribute-definition)
            * 2.0\. [How to implement and consume an attribute](#attribute-howto)
                * 2.1\. [Attributes with parameters](#attribute-params)

            &lt;h2 id=&quot;attribute-definition&quot;&gt;1.0 What is an attribute?&lt;/h2&gt;
            
            Usually class definitions contain a class ctor, properties, methods and/or events, also known as *class members*. Class members define the information and behavior of a given class. 

            In some cases, classes require some descriptive information that may be useful by the consumers. 

            For example, a class may need to define that requires user authentication and the minimum security role to use its members is *administrator*. 

            How can an arbitrary class tell the environment &quot;*I will not work if the authenticated user is not an administrator*&quot;? **The answer is *attributes**.*

            An attribute is an inherited class of &#x60;Attribute&#x60; which defines some metadata that can be identified by other pieces and it is added to the class definition during desing-time.

            Finally, a class supports as many attributes as the code requires. The &#x60;attributes&#x60; parameters for the &#x60;$def&#x60; operator is an array of attributes.

            &lt;h2 id=&quot;attribute-howto&quot;&gt;2.0 How to implement and consume an attribute&lt;/h2&gt;
            
            The so-called *I will not work if the authenticated user is not an administrator* attribute may be implemented as a class called &#x60;RequiresAuthenticationAttribute&#x60;:

                $namespace.register(&quot;myNamespace&quot;, function() {
                    this.declareClass(&quot;RequiresAuthenticationAttribute&quot;, {
                        inherits: $global.joopl.Attribute
                    });
                });

            Later on, some class that may require authentication to work will apply the whole &#x60;RequiresAuthenticationAttribute&#x60; as follows:

                $namespace.register(&quot;myNamespace&quot;, function() {
                    this.declareClass(&quot;MyClass&quot;, {
                        attributes: [new this.RequiresAuthenticationAttribute()]
                    });
                });

            Finally, some other code which instantiate the &#x60;MyClass&#x60; class will inspect if the class requires authentication:

                $namespace.using(&quot;myNamespace&quot;, function() {
                    if(this.MyClass.type.hasAttribute(this.RequiresAuthenticationAttribute)) {
                        // Do some stuff if MyClass has the whole attribute
                    } else {
                        throw Error(&quot;Sorry, this code will not execute classes if they do not require authentication...&quot;);
                    }
                });

            &lt;h3 id=&quot;attribute-params&quot;&gt;2.1 Attributes with parameters&lt;/h3&gt;
            Sometimes using an attribute *as is* is not enough, because the attribute itself should contain data. 

            For example, some code may require some classes to define a default property. &#x60;Person&#x60; class may have &#x60;FirstName&#x60;, &#x60;Surname&#x60; and &#x60;Nickname&#x60; properties. Which one will be the one to display in some listing?

                $namespace.register(&quot;myNamespace&quot;, function() {
                    this.declareClass(&quot;DefaultPropertyAttribute&quot;, {
                        inherits: $global.joopl.Attribute,
                        ctor: function(args) {
                            this._.defaultPropertyName = args.defaultPropertyName;
                        },
                        members: {
                            get defaultPropertyName() { return this._.defaultPropertyName; }
                        }
                    });

                    this.declareClass(&quot;Person&quot;, {
                        attributes: [new this.DefaultPropertyAttribute(&quot;nickname&quot;)],
                        ctor: function() {
                            this._.firstName = null;
                            this._.surname = null;
                            this._.nickname = null;
                        }
                        members: {
                            get firstName() { return this._.firstName; },
                            set firstName(value) { this._.firstName = value; },

                            get surname() { return this._.surname; },
                            set surname(value) { this._.surname = value; },

                            get nickname() { return this._.nickname; },
                            set nickname(value) { this._.nickname = value; }
                        }
                    });
                });

            
            Now, some code consumes instances of &#x60;Person&#x60; and creates some HTML listing using standard DOM and the display name for the whole person will be taken from the &#x60;DefaultPropertyValueAttribute&#x60;:

                $namespace.using(&quot;myNamespace&quot;, function() {
                    
                    // The first step is creating a regular instance of Person
                    var person = new this.Person();
                    person.firstName = &quot;Matias&quot;;
                    person.surname = &quot;Fidemraizer&quot;;
                    person.nickname = &quot;mfidemraizer&quot;;

                    // Secondly, this is checking if the Person class has the whole attribute
                    if(Person.type.hasAttribute(this.DefaultPropertyAttribute)) {
                        // Yes, it has the attribute!
                        //
                        // Then, the attribute instance is retrieved from the type information
                        var defaultProperty = Person.type.getAttribute(this.DefaultPropertyAttribute);

                        // Once the attribute is retrieved, the code can access the &quot;defaultPropertyName&quot; instance property
                        // of the DefaultPropertyAttribute
                        var defaultPropertyName = defaultProperty.defaultPropertyName;
                        
                        // Since any object is also an associative array (this is plain JavaScript!), 
                        // the default property can be retrieved by using the &quot;defaultPropertyName&quot; variable
                        // as key of the array
                        var defaultPropertyValue = person[defaultPropertyName];

                        // Finally, this is creating a paragraph containing the defaultPropertyValue. In this case, 
                        // it will be &quot;mfidemraizer&quot;, because the Person class has the DefaultPropertyAttribute set to &quot;nickname&quot;!
                        var p = document.createElement(&quot;p&quot;);
                        p.appendChild(document.createTextNode(defaultPropertyValue));
                        document.body.appendChild(p);
                    }
                });
        
            @class Attribute
            @since 2.3.0
        */
        this.declareClass(&quot;Attribute&quot;, {
            members: {
            }
        });

        /**
            Represents an enumeration value and provides access to common operations for the whole enumeration value.

            See {{#crossLink &quot;$enumdef&quot;}}{{/crossLink}} to learn more about enumerations.

            @class EnumValue
            @final
            @since 2.3.0
        */
        var EnumValue = $def(&quot;EnumValue&quot;, { name: &quot;joopl&quot; }, {
            ctor: function (args) {
                this._.value = args.value;
            },
            members: {
                /** 
                    Gets the enumeration value.

                    @property value
                    @type Number
                */
                get value() { return this._.value; },

                /** 
                    Performs a bitwise OR with the given enumeration value

                    @method or
                    @param enumValue {Number} An enumeration value
                    @return {Number} The flag of two or more enumeration values
                    @example 
                        var flag = State.open.enum.or(State.closed); // This is State.open | State.closed
                */
                or: function (enumValue) {
                    var value = this.value | enumValue;

                    var result = new Number(value);
                    result.enum = new EnumValue({ value: value });

                    Object.freeze(result);

                    return result;
                },

                /** 
                    Performs a bitwise AND with the given enumeration value

                    @method and
                    @param enumValue {Number} An enumeration value
                    @return {Number} The flag of two or more enumeration values
                    @example var flag = State.open.enum.and(State.closed); // This is State.open &amp; State.closed
                */
                and: function (enumValue) {
                    var value = this.value &amp; enumValue;

                    var result = new Number(value);
                    result.enum = new EnumValue({ value: value });

                    Object.freeze(result);

                    return result;
                },

                /** 
                    Determines if some enumeration value contains other enumeration value.

                    @method hasFlag
                    @param enumValue {Number} An enumeration value
                    @return {Boolean} A boolean specifying if the given enumeration value was found in the flag.
                    @example 
                        var flag = State.open.enum.or(State.closed);
                        var hasOpen = flag.enum.hasFlag(State.open);
                */
                hasFlag: function (enumValue) {
                    return (this.value &amp; enumValue) === Number(enumValue);
                }
            }
        });

        /**
            Represents an utility class to work with enumerations.

            @class Enum
            @static
            @since 2.3.0
        */
        this.Enum = new ($def(&quot;Enum&quot;, this, {
            members: {
                /** 
                    Parses a text into a given enumeration value

                    @method parseName
                    @param enumType {enum} The enumeration definition (i.e. *State*, *ConnectionTypes*, ...)
                    @param valueName {string} The value name to be parsed (i.e. If an enumeration called States would have an *open* and *closed* values, *open* or *closed* would be a value names)
                    @static
                    @example
                        $namespace.using(&quot;joopl&quot;, function() {
                            this.declareEnum(&quot;State&quot;, {
                                open: 1,
                                closed: 2
                            });

                            var open = this.Enum.parseName(State, &quot;open&quot;)
                        });
                */
                parseName: function (enumType, valueName) {
                    if (enumType.valueNames.indexOf(valueName) &gt; -1) {
                        return enumType[valueName];
                    } else {
                        throw new scope.ArgumentException({
                            argName: &quot;valueName&quot;,
                            reason: &quot;Given value name could not be found as value of the given enumeration type&quot;
                        });
                    }
                },

                /** 
                    Parses a comma-separated list of text values as a mask of given enumeration

                    @method parseNames
                    @param enumType {enum} The enumeration definition (i.e. *State*, *ConnectionTypes*, ...)
                    @param valueNames {String} A comma-separated list of a mask of given enumeration type (i.e. &quot;open, closed, working&quot;).
                    @static
                    @example
                        $namespace.using(&quot;joopl&quot;, function() {
                            this.declareEnum(&quot;State&quot;, {
                                open: 1,
                                closed: 2
                            });

                            this.Enum.parseNames(State, &quot;open, closed&quot;)
                        });
                */
                parseNames: function (enumType, valueNames) {
                    if (!(valueNames &amp;&amp; typeof valueNames == &quot;string&quot;)) {
                        throw new scope.ArgumentException({
                            argName: &quot;valueName&quot;,
                            reason: &quot;Wrong value names&quot;
                        });
                    }

                    var valueNamesArr = valueNames.replace(&quot; &quot;, &quot;&quot;).split(&quot;,&quot;);
                    var value = 0;

                    for (var nameIndex = 0; nameIndex &lt; valueNamesArr.length; nameIndex++) {
                        value += this.parseName(enumType, valueNamesArr[nameIndex])
                    }

                    return new EnumValue({ value: value });
                }
            }
        }));

        $enumdef = function (name, namespace, enumDef) {
            if (typeof enumDef != &quot;object&quot;) {
                throw new scope.ArgumentException({
                    argName: &quot;enumDef&quot;,
                    reason: &quot;No definition for the enumeration given&quot;
                });
            }

            var enumerationType = function () {
            };

            enumerationType.prototype = new scope.Object();

            var enumNames = [];
            var enumValue;

            for (var propertyName in enumDef) {
                if (typeof enumDef[propertyName] != &quot;number&quot;) {
                    throw new scope.ArgumentException({
                        argName: &quot;enumDef&quot;,
                        reason: &quot;An enumeration definition must contain numeric properties only&quot;
                    });
                }

                enumValue = new Number(enumDef[propertyName]);
                enumValue.enum = new EnumValue({ value: enumValue });

                Object.defineProperty(
                    enumerationType,
                    propertyName, {
                        value: enumValue,
                        configurable: false,
                        enumerable: true,
                        writable: false
                    }
                );

                enumNames.push(propertyName);
            }

            Object.defineProperty(
                enumerationType,
                &quot;valueNames&quot;,
                {
                    value: enumNames,
                    configurable: false,
                    enumerable: true,
                    writable: false
                }
            );

            Object.defineProperty(
                enumerationType,
                &quot;type&quot;, {
                    value: new $global.joopl.Type({ name: name, fullName: namespace.fullName + &quot;.&quot; + name, namespace: namespace }),
                    writable: false,
                    configurable: false,
                    enumerable: true
                }
            );

            Object.freeze(enumerationType);

            return enumerationType;
        };

        Object.freeze($enumdef);

        this.declareClass(&quot;Event&quot;, {
            ctor: function (args) {
                this._.handlers = [];
                this._.source = args.source;
            },
            members: {
                get handlers() { return this._.handlers; },
                get source() { return this._.source; },

                addEventListener: function (handler) {
                    var index = this.handlers.indexOf(handler);

                    if (index == -1) {
                        this.handlers.push(handler);
                    }
                },

                removeEventListener: function (handler) {
                    var index = this.handlers.indexOf(handler);

                    if (index &gt;= 0) {
                        this.handlers.splice(index, 1);
                    }
                },

                raise: function (args) {
                    if (this.handlers.length &gt; 0) {
                        for (var delegateIndex in this.handlers) {
                            this.handlers[delegateIndex].bind(args ? (args.$this ? args.$this : this.source) : this.source)(args ? (args.args ? args.args : null) : null);
                        }
                    }
                }
            }
        });

        this.declareClass(&quot;EventManager&quot;, {
            ctor: function (args) {
                this._.source = args.source;
            },
            members: {
                get source() {
                    return this._.source;
                },

                register: function (eventName) {
                    var delegates = [];
                    var that = this;
                    var source = this.source;

                    Object.defineProperty(
                        this,
                        eventName, {
                            value: new $global.joopl.Event({ source: this.source }),
                            writable: false,
                            configurable: false,
                            enumerable: true
                        }
                    );
                }
            },
        });

        /**
            Represents a set of environmental values and operations

            @class Environment
            @final
        */
        this.declareClass(&quot;Environment&quot;, {
            members: {
                /**
                    Occurs when any exception of any type is thrown within current application

                    @event exceptionThrown
                    @param {joopl.Exception} thrownException The exception that has been thrown
                    @example
                        // Listening exceptions...
                        $global.joopl.Environment.current.exceptionThrown.addEventListener(function(e) {
                            var exception = e.thrownException;
                        });

                        // Raising the event...
                        $global.joopl.Environment.current.notifyException(someException);
                */
                events: [&quot;exceptionThrown&quot;],

                /**
                    Notifies a given exception to all subscribers

                    @method notifyException
                    @param {joopl.Exception} exception The exception to be notified
                    @example 
                        $global.joopl.Environment.current.notifyException(someException);
                */
                notifyException: function (exception) {
                    this.exceptionThrown.raise({ args: { thrownException: exception } });
                }
            }
        });

        /**
            Gets current Environment instance

            @property current
            @type Environment
            @readonly
            @static
        */
        Object.defineProperty(
            this.Environment,
            &quot;current&quot;, {
                value: new this.Environment(),
                writable: false,
                configurable: false,
                enumerable: true
            }
        );

        /**
            Represents the base class for any exception 

            @class Exception
        */
        this.declareClass(&quot;Exception&quot;, {

            /**
                @class Exception
                @constructor
                @param {string} message A human-readable reason text for the whole exception
                @param {Exception} innerException An inner exception that is more specific to occured error
                @example 
                    throw new Error($global.joopl.Exception({ message: &quot;Some&quot;, innerException: otherException }));
            */
            ctor: function (args) {
                this._.message = args.message;
                this._.innerException = args.innerException;

                $global.joopl.Environment.current.notifyException(this);
            },

            members:
            {
                /**
                    Gets the human-readable reason text for this exception

                    @property message
                    @type string
                    @readonly
                */
                get message() {
                    return this._.message;
                },

                /**
                    Gets an inner exception (optional) which provides for information about the sorrounding one

                    @property innerException
                    @type Exception
                    @readonly
                */
                get innerException() {
                    return this._.innerException;
                },

                toString: function () {
                    return &quot;An exception of type &#x27;&quot; + this.type.fullName + &quot;&#x27; has been thrown with message &#x27;&quot; + this.message + &quot;&#x27;&quot;;
                }
            }
        });

        /**
            Represents an exception that occurs when some method argument is missing or invalid

            @class ArgumentException
            @extends joopl.Exception
        */
        this.declareClass(&quot;ArgumentException&quot;, {
            inherits: this.Exception,

            /**
                @class ArgumentException
                @constructor
                @param {string} argName The affected argument name
                @example
                    throw new Error(new $global.joopl.ArgumentException({ argName: &quot;someArgument&quot;}));
            */
            ctor: function (args) {
                this._.argName = args.argName;

                var message = &quot;The given argument &#x27;&quot; + args.argName + &quot;&#x27; is not valid&quot;;

                if (args.reason) {
                    message += &quot; (Reason: &quot; + args.reason + &quot;)&quot;;
                }

                this.base.ctor({
                    message: message
                });
            },
            members: {

                /**
                    Gets the affected argument name

                    @property argName
                    @type string
                    @readonly
                */
                get argName() {
                    return this._.argName;
                }
            }
        });

        /**
            Represents an exception that occurs when a class member is not implemented

            @class NotImplementedException
            @extends joopl.Exeption
        */
        this.declareClass(&quot;NotImplementedException&quot;, {
            inherits: this.Exception,

            /**
                @class NotImplementedException
                @constructor
                @param {string} memberName The affected member name which does not implement something
                @example
                    throw new Error(new $global.joopl.NotImplementedException({ memberName: &quot;someMethod&quot;}));
            */
            ctor: function (args) {
                this.base.ctor(
                    {
                        message: !TypeUtil.hasValue(args) || !TypeUtil.hasValue(args.memberName) ?
                                        &quot;A method or property is not implemented&quot;
                                        :
                                        &quot;Method or property &#x27;&quot; + args.memberName + &quot;&#x27; is not implemented&quot;
                    }
                );

                this._.memberName = args.memberName;
            },
            members: {
                /**
                    Gets the not implemented member name

                    @property memberName
                    @type string
                    @readonly
                */
                get memberName() {
                    return this._.memberName;
                }
            }
        });
    });
})(undefined);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <footer id="page-footer">
        &copy; 2013 <a href="http://www.linkedin.com/in/mfidemraizer/en" target="_blank">Matias Fidemraizer</a>. jOOPL is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank">Apache License 2.0.</a>
    </footer>
    <script src="../assets/vendor/prettify/prettify-min.js"></script>
    <script>prettyPrint();</script>
    <script src="../assets/js/yui-prettify.js"></script>
</body>
</html>
